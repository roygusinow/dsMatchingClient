% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ds.vcovCL.R
\name{ds.vcovCL}
\alias{ds.vcovCL}
\title{This function computes a heteroskedasticity-consistent (HC) sandwich variance-covariance matrix
for a GLM model fitted in a federated DataSHIELD setting. The sandwich estimator supports
HC0–HC3 types and optional cluster-robust inference.}
\usage{
ds.vcovCL(fit, data, error_type = "HC0", clusters, datasources = NULL)
}
\arguments{
\item{fit}{A list. Output from `ds.glm`, containing at least `VarCovMatrix`, `nsubs`, and `coefficients`.}

\item{data}{A character string. The name of the data frame on the server-side.}

\item{error_type}{A character string. Type of heteroskedasticity-consistent estimator to use. One of `"HC0"`, `"HC1"`, `"HC2"`, or `"HC3"`. Default is `"HC0"`.}

\item{clusters}{A numeric vector. Subclass labels (or other cluster IDs) used to aggregate estimating functions.}

\item{datasources}{A list of `DSConnection-class` objects. If `NULL`, the function uses `datashield.connections_find()` to detect active connections.}
}
\value{
A numeric matrix representing the robust variance-covariance matrix of the estimated model parameters.
}
\description{
This function computes a heteroskedasticity-consistent (HC) sandwich variance-covariance matrix
for a GLM model fitted in a federated DataSHIELD setting. The sandwich estimator supports
HC0–HC3 types and optional cluster-robust inference.
}
\details{
The function constructs the sandwich estimator as \( B × M × B / n \), where:
\itemize{
  \item \( B \) is the scaled variance-covariance matrix ("bread") adjusted for dispersion.
  \item \( M \) is the cluster-aggregated estimating function matrix ("meat"), computed using `ds.estfun`.
}
This implementation supports cluster-robust corrections using the `meatCL_ds()` helper, and leverages
server-side assignments for computing hat matrix diagonals (`ds.hat_diag`) and score functions.

The cluster-robust variance--covariance matrix is computed using the sandwich
estimator
\deqn{
\widehat{V} = \widehat{A}\,\widehat{B}\,\widehat{A}
}
where the ``bread'' estimator \eqn{\widehat{A}} is based on the empirical inverse
Hessian of the objective function \eqn{\Psi(y, x, \beta)}. The ``meat'' estimator
is given by

\deqn{
\widehat{B}
=
\frac{1}{N}
\sum_{s=1}^{S}
\sum_{h=1}^{H}
\left(
\sum_{i=1}^{n_{s,h}}
\psi\!\left(
y_{s,h,i},
x_{s,h,i},
\widehat{\beta}_{ATE}
\right)
\right)
\left(
\sum_{i=1}^{n_{s,h}}
\psi\!\left(
y_{s,h,i},
x_{s,h,i},
\widehat{\beta}_{ATE}
\right)
\right)^{T}
}

where \eqn{\psi} denotes the estimating function. For generalized linear models
implemented within DataSHIELD, \eqn{\psi} is equivalent to the evaluated score
function, i.e.\ the first derivative of the log-likelihood \eqn{\Psi}. In this
setting, the quantities communicated to the central client are products of
residuals and the design matrix, which are not recoverable at the individual
level once transmitted.

When the number of clusters \eqn{H} is small, clusters residing on the same
server may be aggregated locally prior to communication with the central client.

**Server-side functions called**:
\itemize{
  \item None, but uses `ds.dispersion`, `ds.hat_diag`, and `ds.estfun` to compute necessary components.
}
}
\author{
Roy Gusinow
}
